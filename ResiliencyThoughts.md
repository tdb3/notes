# Initial Thoughts on Bitcoin's Resiliency
For the time being, these are simply musings and thoughts.  Ideas being sent into the wild.  Some of these may very well be addressed more than what I've seen thus far.

## Code Collaboration Continuity:
Bitcoin Core uses GitHub (as other Bitcoin projects do) as an excellent tool for collaboration.  GitHub enables effective communication, efficient code review, and a convenient push point for commits. 
However, GitHub is owned by a centralized entity (currently Microsoft).  Other sites exist for the distribution of Bitcoin Core binaries and source (e.g. bitcoincore.org/en/download, torrents, etc.) including signatures by known Core developers.  IRC (bitcoin-core-dev) exists for development conversations.  However, if for some reason access to the Bitcoin Core repo on Github were to become unavailable (e.g., a policy change by Microsoft, outage, etc.), what's the plan for continuity of code collaboration within GitHub Issues and Pull Requests (PRs)?

Yup, there is irony here (as I'm inviting PRs for this file/repo through GitHub).

Yes, git itself is a distributed version control system, so commits could be pushed/pulled among individual developer machines.  However, what of the Issues, PRs, and associated comments?  Is this available elsewhere simultaneously or being periodically archived independently?  Bitcoin is essentially a distributed database (ledger) system with participants non-dependent on any single given node for the availability of the database, but are we relying on GitHub as the central point for particular aspects of the development of this distributed system?  Perhaps with Bitcoin being as mature as it is currently,  these risks are pretty far out on the tail.  Nonetheless:
- Losing PR/comment history could slow down continued development
- Losing code collaboration tool access could slow down continued development
Even just the chaos of inducing these types of incidents could perhaps serve as a useful ancillary measure or diversion to support an attack on Bitcoin.  A 10,000 ft high example:  Find a problem/vulnerability in Core, induce chaos in the development process, and exploit the problem/vulnerability.  It would expected that the adversary wouldn't exactly be responsibly disclosing the issue if the intent was disruption and exploitation.

Ideally, we should ensure development continues "business as usual" as much as possible/practical in the event of the unavailability of Core on GitHub.  The tradeoff being that spending too much effort "prepping" takes away from other endeavors.

In other industries/environments, it is common for development to occur through contractual agreements with third-party entities.  In these arrangements, there are typically contractual escrow clauses to ensure continuity in the event that a contracted developer relationship is unexpectedly discontinued (e.g., the company goes under, decides the contract is no longer worth their time/resources, etc.).  The content being escrowed usually includes not just source code, but build environment, support tools, documents, comments, correspondences, etc. to preserve history and enable a new developer to (as quickly as possible) continue development.  It is also not uncommon for there to be development contracts jointly awarded to more than one developer.  This enables resiliency of development (and in some instances promotes healthy competition to keep things efficient).  Similarly, it would seem prudent to have increased resiliency or a continuity/contingency plan in place to mitigate the risk.

Web apps and frontends for git repositories exist (e.g. Gitea, Gitlab, etc.), but are typically hosted on a central server (so central point for attack).
There could be value in identifying, or developing/refining, a more decentralized code collaboration tool for Core.  Perhaps independently run hot clones of the PR/comments from Github?  In the past, some have mused the idea of using Nostr as a replacement for the dev mailing list.  While Nostr doesn't seem like a great fit for a mailing list, perhaps the development of a code collaboration tool on a decentralized protocol could help with continuity.  Wouldn't have to necessarily be Nostr (not everything is a nail just because we have a hammer), but the thought remains:  Can we reduce dependencies on centralized entities for as many parts of the development process as possible (e.g., including collaboration tools)?

## Dependency Lifecycle Monitoring
It is common for projects to identify a process for component lifecycle management.  The goal is to identify upcoming significant and necessary migrations or other catalysts for change in a proactive way, providing additional prep and insight for planning.  Within the hardware space, this involves identifying hardware components that manufacturers have tagged as end-of-life/support, last buy, not recommended for new designs, etc.  Within the software space, this may involve identifying and monitoring roadmaps, support cycles, and patching cadence for dependencies.  While Bitcoin Core may have a relatively small set of dependencies (https://github.com/bitcoin/bitcoin/blob/master/doc/dependencies.md), Core as well as other Bitcoin applications may benefit from increased monitoring of dependencies.
Perhaps tools for monitoring dependency releases, criticality labeling, and focused continuous integration tools may help enhance monitoring capabilities.  While it's true that Bitcoin Core allows older versions of node software to be run and remain in consensus, some older versions are simply not recommended due to associated vulnerabilities.

## Failure Modes and Effects Analysis (FMEA)
When developing mission-critical systems, a process called FMEA is typically employed to identify as much as possible, the ways in which components of the system can fail, and the resultant ripple effects of these failures.  While sometimes tedious, writing down individual failure scenarios and thinking logically about the ripple effects is for systems engineers what, in part, unit tests are for software engineers and threat assessment is for security engineers.  Probabilities are typically included for failure modes (ancillary for helping determine Mean Time Between Failure) of the system.  From a practical standpoint, enumerating failures helps alleviate fear of the unknown, provides perspective for what can go wrong, and organizes thoughts for constructive discussion.  Discussion of soft fork proposals for Bitcoin can be quite contentious.  Laying out concerns as specific failure modes and examples in a structured way can greatly increase understanding for all involved, and leads to more informed decision making.
